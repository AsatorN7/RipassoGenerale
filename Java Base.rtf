{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1040{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset2 Wingdings;}{\f2\fnil Consolas;}{\f3\fnil\fcharset0 Consolas;}{\f4\fnil Calibri;}}
{\colortbl ;\red0\green0\blue0;\red27\green98\blue145;}
{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs22\lang16 1) Definizione di algoritmo.\b0\par
Flusso logico delle azioni da compiere per raggiungere un obiettivo e/o risolvere un problema. Ha sempre un inizio ed una fine e prevedere l\rquote utilizzo di strutture logiche quali: strutture condizionali e cicli.\par
\b 2) Definizione di programma.\b0\par
Insieme di algoritmi che tradotto da sorgente in linguaggio macchina (da un compilatore), indica alla cpu le operazioni da fare per risolvere un problema. \par
\b 2bis) Quali sono le fasi di progettazione del software?\b0\par
\b\f1\'b7\f0  Analisi \b0 (Esplicitazione dei requisiti. Analisi dei requisiti. Analisi del dominio. Analisi di fattibilit\'e0 Analisi dei costi): ci rivolgiamo al cliente per raccogliere le sue richieste e proporre eventualmente soluzioni alternative.\par
\b\f1\'b7\f0  Progettazione \b0 (Progetto architetturale. Localizzazione software. Progetto di dettaglio): la\par
progettazione prevede l\rquote uso dei diagrammi di flusso e l\rquote uml, ovvero, un linguaggio grafico per rappresentare la gerarchia di interfacce e classi che compongono il nostro progetto.\par
\b\f1\'b7\f0  Programmazione\b0 : scrittura del codice.\par
\b\f1\'b7\f0  Ispezione \b0 e Debugging: controllo degli errori.\par
\b\f1\'b7\f0  Collaudo\b0 : valutazione della correttezza rispetto alle specifiche da parte dei tester. Possono essere individuate due sottoattivit\'e0: collaudo dei singoli moduli e collaudo del sistema integrato; inoltre possono essere individuate ulteriori sottoattivit\'e0 per ogni aspetto del prodotto software che interessa collaudare: collaudo funzionale, collaudo di performance, collaudo di rottura, collaudo di regressione, collaudo di sicurezza, collaudo di accessibilit\'e0, collaudo di accettazione, ecc. . In caso di mancato rispetto delle specifiche il software, assieme al documento delle anomalie o bug, torna indietro agli sviluppatori con il compito di risolvere i problemi riscontrati attraverso anche il debugging del software. In genere le anomalie di funzionamento sono gestite tramite appositi software gestori di segnalazione anomalie, detti anche sistemi di ticketing o di bug tracking, che registrano i problemi segnalati al team di sviluppo e ne facilitano la relativa organizzazione, classificazione e gestione (p. es. Bugzilla, Mantis, Atlassian Jira, ecc.).\par
\b\f1\'b7\f0  Deployment\b0 : rilascio e messa in esercizio.\par
\b\f1\'b7\f0  Manutenzione\b0 : fase di post-vendita, in cui si rilasciano patch correttive con eventuale intervento nella sede del cliente. \par
\cf1\b 2tris) Cosa sono i diagrammi di flusso?\par
\cf0\b0 Sono rappresentazioni grafiche di algoritmi, composte da blocchi chiamati: diagrammi e linee. I diagrammi hanno diverse forme in funzione di quello che indicano: mentre le linee rappresentano i possibili percorsi da seguire. \par
\b 3) Differenza tra: linguaggio interpretato e linguaggio compilato.\par
\b0 I linguaggi compilati prevedono il codice scritto in un editor, al pi\'f9 utilizzando un ambiente di sviluppo IDE che ne facilita la creazione; questo codice viene controllato per verificare che non ci siano errori e poi compilato, ovvero ogni istruzione viene trasformata in linguaggio macchina che pu\'f2 essere, cos\'ec, eseguito dal processore. Di contro, i linguaggi interpretati vedono il codice sorgente interpretato al volo e vengono, quindi, eseguite le istruzioni cos\'ec come descritte nel codice sorgente; un esempio su tutti sono PHP e Javascript. Un linguaggio interpretato \'e8 anche detto di scripting. \b\par
4) Cosa \'e8 una variabile?\par
\b0 Cella della porzione di memoria ram (gestita dalla JVM nel caso di Java). Una variabile \'e8 allocata nella method area se statica, nella heap memory se variabile di istanza (attributo di un oggetto) e nello stack memory se locale in un metodo. \par
il tipo corrisponde alla dimensione della cella\par
\'e8 possibile inserire un modificatore di accesso public, private o protected per l'attributo nel caso di nessuna dichiarazione l'attributo prender\'e0 il valore di default\par
int a=23; inserendo un valore nella cella\par
int b;prenoto cella di memoria (il valore di default \'e8 diretto al tipo primitivo)\par
i tipi primitivi sono 8 \par
byte(8 bit/1 byte,),short(16 bit/2byte),int(32 bit/4byte),long(64 bit/8 byte) valore di default = 0 per il long anche 0L\par
float(32 bit/4 byte) , double (64 bit/8byte) valore di default=  float 0.0f double 0.0d\par
boolean (1 bit) valore di default false\par
char (16 bit/2 byte) valore di default \\u0000 o a 0.655\par
Attributo\par
int=Tipo di dato primitivo.\par
 a=  riferimento alla cella di memoria.  \par
=   operatore in questo caso per  passare il valore da inizializzare\par
dato/informazione inizializzazione.\par
\par
\par
\b 5) Quale vantaggio offre Java a valle di una compilazione?\par
\b0 La trasportabilit\'e0 grazie alla JVM. Ogni sistema operativo pu\'f2 avere la relativa JVM; quest\rquote ultima esegue il bytecode e non il linguaggio macchina, svincolando la cpu dall\rquote onere di eseguire l\rquote applicazione. Un programma scritto in Java diventa trasportabile proprio perch\'e9 non si ha pi\'f9 la dipendenza dal processore fisico, sostituito dalla macchina virtuale, la JVM. \par
\b 6) Date due variabili cos\'ec inizializzate: int a=10; int b=3; si ricavi il \ldblquote preciso\rdblquote  risultato dato dal rapporto tra i due valori. \par
\cf1\f2 public static void main(String[] args) \{\par
\par
\tab\tab String palindromo="barba";\par
\tab\tab boolean flag=true;\par
\tab\tab\par
\tab\tab for (int i=0;i<palindromo.length()/2;i++) \{\par
\tab\tab\tab if (palindromo.charAt(i)!=palindromo.charAt(palindromo.length()-i-1)) \{\par
\tab\tab\tab\tab flag = false;\par
\tab\tab\tab\}\par
\tab\tab\f3\lang1040\}\f2\lang16\par
\tab\tab if (flag) \{\par
\tab\tab\tab System.\i out\i0 .println("la parola \f3\'e8 palindroma"\f2 );\par
\tab\tab\}\par
\tab\tab else \{\par
\tab\tab\tab System.\i out\i0 .println("la parola non \f3\'e8 palindroma"\f2 );\par
\tab\tab\}\par
\f0 8) Dato un vettore di interi contenente i valori: 2,7,1, scrivere l\f4\rquote\f0 algoritmo capace di effettuare il corretto ordinamento dei numeri. \par
\f2 public static void main(String[]args) \{\par
\tab\tab int []v= \{2,7,1\};\par
\tab\tab\par
\tab\tab for (int i=0;i<v.length;i++) \{\par
\tab\tab\tab for(int j=i;j>0;j--) \{\par
\tab\tab\tab\tab if (v[j]<v[j-1]) \{\par
\tab\tab\tab\tab\tab int temp=v[j-1];\par
\tab\tab\tab\tab\tab v[j-1]=v[j];\par
\tab\tab\tab\tab\tab v [j]=temp;\par
\tab\tab\tab\tab\}\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab for (int \highlight2 i\highlight0 =0;\highlight2 i\highlight0 <v.length;\highlight2 i\highlight0 ++) \{\par
\tab\tab\tab System.\i out\i0 .println(v[\highlight2 i\highlight0 ]);\par
\tab\tab\}\par
\tab\}\par
\b0\fs28\par
\f0\fs22 9) Dato un ArrayList di stringhe contenente i valori: \f4\ldblquote\f0 Mirko\f4\rdblquote\f0 ,\f4\rdblquote\f0 Alessandro\f4\rdblquote\f0 ,\f4\rdblquote\f0 Ugo\f4\rdblquote\f0 ,\f4\rdblquote\f0 Anna\f4\rdblquote\f0 , scrivere\par
l\f4\rquote\f0 algoritmo che faccia prima un ordinamento (dalla stringa pi\'f9 corta alla pi\'f9 lunga) e che poi elimini\par
dall\rquote ArrayList le stringhe dal numero dispari di caratteri. \f3\fs28\par
\f2\fs22 public static void main(String[] args) \{\par
\par
\tab\tab ArrayList<String> \highlight2 nomi\highlight0 =new ArrayList<String>();\par
\tab\tab\highlight2 nomi\highlight0 .add("Mirko");\par
\tab\tab\highlight2 nomi\highlight0 .add("Alessandro");\par
\tab\tab\highlight2 nomi\highlight0 .add("Ugo");\par
\tab\tab\highlight2 nomi\highlight0 .add("Anna");\par
\tab\tab\par
\tab\tab for (int i=0;i<\highlight2 nomi\highlight0 .size();i++) \{\par
\tab\tab\tab for(int j=\highlight2 nomi\highlight0 .size()-1;j>i;j--) \{\par
\tab\tab if (\highlight2 nomi\highlight0 .get(i).length()>\highlight2 nomi\highlight0 .get(j).length()) \{\par
\tab\tab\tab String temp=\highlight2 nomi\highlight0 .get(i);\par
\tab\tab\tab\highlight2 nomi\highlight0 .set(i, \highlight2 nomi\highlight0 .get(j));\par
\tab\tab\tab\highlight2 nomi\highlight0 .set(j, temp);\par
\tab\tab\}\par
\tab\tab\}\par
\tab\tab\par
\tab\tab\}\par
\tab\tab for(String nome:\highlight2 nomi\highlight0 ) \{\par
\tab\tab System.\b\i out\b0\i0 .println(nome);\par
\tab\tab\}\par
\tab\tab\}\par
\b\f0 10) Cosa sono una Classe ed un oggetto.\par
\cf0\b0\par
\cf1\b\f2\par
\b0 Una classe \f3\'e8: una struttura di programmazione, un tipo di dato ed il disegno di un oggetto; per tanto, un oggetto \'e8 l\rquote istanza di una classe. \par
All'interno di una classe vengono implementare attributi (variabili di istanza) metodi e costruttori.\par
\cf0\f0 public class MiaCalsse\{\par
Attributi (Variabili d'istanza)\par
Metodi\par
Costruttori\par
\}\par
\cf1\f3\par
\cf0\b\f0 10bis) Che cos'\'e8 un oggettto\par
\b0 l'oggetto \'e8 l'Istanza di una classe\par
MiaClasse miaClasse=new MiaClasse();\par
MiaClasse=Classe\par
miaClasse=Nome oggetto (riferimento oggetto e quindi indirizzo )\par
new=Comando che crea l'oggettto\par
MiaClasse()=Costruttore.\par
\par
Esempio d'uso di un costruttore:\par
public class MiaClasse\{\par
Persona p=new Persona(); //Non \'e8 proprio corretta\par
Persona p;\par
...\par
public MiaClasse()\{\par
this.p=new Persona();\par
\}\par
\}\par
\par
\cf1\b\f2\fs28\par
\cf0\ul\f0\fs22 11) Si faccia l\rquote esempio classico sull\rquote overload.\par
\ulnone\b0 L\rquote esempio classico \'e8 quello del costruttore. In una classe posso avere sia il costruttore di default che uno o pi\'f9 costruttori parametrizzati. Nel momento in cui dichiaro dei costruttori parametrizzati, quello di default va dichiarato esplicitamente in quanto verrebbe nascosto dalle versioni con parametri.\par
tipi di overload \par
posizionale String, int stessi parametri ma con posizione diverse \par
tipale int, int\par
misto String, int, int\par
numerico String, int, obj\par
\par
\par
\cf1\b 12) Cosa \'e8 un costruttore? A che serve e cosa lo distingue dagli altri metodi?\cf0\b0\par
I costruttori servono per inizializzare l'oggetto che si sta creando\par
E\rquote  il metodo che costruisce gli oggetti quando accompagnato dalla keyword new. Costruire un oggetto significa allocarlo nella memoria heap. Ogni new+costruttore alloca un nuovo oggetto e quindi viene definito un nuovo riferimento. Rispetto i metodi comuni segue le seguenti regole: \par
1) Stesso nome della classe di appartenenza\par
2) Nella dichiarazione del metodo non \'e8 indicato il tipo restituito\par
\par
\par
\b 13) Si descriva nel dettaglio il pattern MVC.\par
\b0 L\rquote MVC \'e8 un modello architetturale. Ragionando per componenti e quindi responsabilizzando le classi in ruoli, possiamo collocare quest\rquote ultime in tre macrocategorie: Model, View e Controller. \par
Le classi model (o entity) sono classi di archiviazione e nascono per conservare dati sensibili; per tanto, una classe di questo tipo presenta attributi privati, conseguenti setter e getter, eventuali costruttori parametrizzati ed eventuali override dei metodi: toString(), equals() ed hashCode(). \par
Le classi View sono le classi responsabili della gestione degli input ed output, i cui metodi (maschere) sostituiscono i comuni form delle pagine web. \par
Infine, la classi Controller nascono per implementare la logica applicativa e per tanto sono le responsabili dell\rquote esecuzione del programma. Invocando una sequenza di metodi, sono le classi che ricordano il linguaggio procedurale. \par
\par
\b 14) Si descriva il pattern singleton e lo si applichi ad una classe Utility avente i metodi che aprono e\par
chiudono una connessione col db.\par
\b0 Il pattern singleton \'e8 un modello che obbliga una classe ad avere una sola istanza. Per questo motivo prevede che il costruttore sia privato e che ci sia un metodo statico che ritorni l\rquote unica istanza della classe. Questo pattern viene utilizzato per le classi di servizio, ovvero, per le classi che offrono sole funzionalit\'e0. In questi casi non avrebbe senso istanziare pi\'f9 oggetti che svolgono lo stesso compito. Un esempio \'e8 la classe che apre e chiude la connessione ad un database. Usiamo un\rquote unica istanza in quanto sarebbe ridondante creare pi\'f9 oggetti che aprono alla stessa connessione. \par
\cf1\b public class Singleton \{\par
\par
\tab public Connection conn=null;\par
\tab private Singleton() \{\}\par
\tab private static Singleton \i instance\i0 =null;\par
\tab public static Singleton getSingleton() \{\par
\tab\tab if(\i instance\i0 ==null) \{\par
\tab\tab\tab\i instance\i0 =new Singleton();\par
\tab\tab\}\par
\tab\tab return \i instance\i0 ;\par
\tab\}\par
\tab\par
\tab public void apriConnessione() \{\par
\tab\tab try \{\par
\tab\tab\tab Class.\i forName\i0 ("com.mysql.cj.jdbc.Driver");\par
conn= DriverManager.\i getConnection\i0 ("jdbc:mysql://localhost:3306/ecommerce","root","");\par
\tab\tab\} catch (ClassNotFoundException e) \{\par
\tab\tab\tab e.printStackTrace();\par
\tab\tab\} catch (SQLException e) \{\par
\tab\tab\tab e.printStackTrace();\par
\tab\tab\}\par
\tab\}\par
\tab public void chiudiConnessione() \{\par
\tab\tab try \{\par
\tab\tab\tab conn.close();\par
\tab\tab\} catch (SQLException e) \{\par
\tab\tab\tab e.printStackTrace();\par
\tab\tab\}\par
\tab\}\tab\par
\}\par
\cf0 15) Differenza tra classe, classe astratta ed interfaccia.\par
\b0 Una classe astratta non ha differenze da quella comune se non per il fatto che ha ALMENO un metodo astratto (metodo non implementato) e non pu\'f2 istanziare oggetti (in quanto l\rquote istanza si troverebbe ad invocare almeno un metodo non funzionante). Una classe che ne estende una astratta \'e8 obbligata ad implementare i metodi astratti ereditati. Per dichiarare una classe come astratta si usa la keyword abstract tra il modificatore d\rquote accesso ed il nome; per dichiarare un metodo come astratto la stessa keyword va messa tra il modificatore d\rquote accesso ed il tipo di dato ritornato. Le interfacce sono strutture di programmazione, tipi di dato, ma NON classi. Nel periodo pre-Java 8 ammettevano solo metodi astratti (abstract in questo caso non viene messo in quanto presente di default) ed eventuali costanti (l\rquote operatore final non si mette poich\'e9 l\rquote attributo di una interfaccia \'e8 costante di default), mentre con Java 8 le interfacce possono ammettere anche metodi statici e di default; con Java 9 possono ammettere anche metodi privati, evocati in quelli di default.  intando dichiaro una classe astratta quando ho una forte generalizzazione esempio\par
Classe Figura2D -> calcArea() e calcPerimetro()\par
public abstract double calcArea();\par
una classe che ne eredita una astratta deve obbligatorialmente effettuare l'override dei metodi interfaccie nel periodo prejava 8 che non sono ne simili alle classe e n\'e8 classi accettavano solo e soltanto metodi astratti, eventualmente anche  costanti (final non richiesto \'e8 di default)\par
\b\par
\b0\par
\ul\b 16) Perch\'e9 un\rquote interfaccia migliora l\rquote ereditariet\'e0 tra classi? Dopo aver risposto, si faccia un esempio con le Collection.\ulnone\b0\par
Perch\'e9 se una classe figlia pu\'f2 estendere solo una classe padre; di contro, la stessa pu\'f2 implementare pi\'f9 interfacce padre. Ci\'f2 consente una maggiore flessibilit\'e0 in una gerarchia, oltre a rendere meno specifica una classe. Un esempio tipico \'e8 quello della classe LinkedList; come l\rquote ArrayList eredita tutti i metodi dell\rquote interfaccia List, ma in pi\'f9 implementa l\rquote interfaccia Queue, potendosi cos\'ec avvalere di ulteriori metodi come addFirst() e addLast().\par
\par
\b 17) Descrivere gli effetti derivati dagli operatori: static e final.\par
\b0 Final= un operatore che associato ad una classe o ad un oggetto rimane immutabile(immutabilit\'e0) ad un attributo diventa una costante,  il metodo non pu\'f2 subire l'override la classe non pu\'f2 avere figli.\par
\par
costrutto classe= ->classe non ereditabile /estendibile\par
costrutto metodo> metodo non sovrascribile (no override)\par
costrutto attributo -> ottengo una costante \par
 static = vincolo degli oggetti \par
variabile statica= non sottraibile non viene presa dall'oggetto da una istanza/oggetto(rimangono)\par
una variabile statica non pu\'f2 essere variabile di istanza\par
metodo statico=non \'e8 necessario l'oggetto\par
nell'utilizzo dell'object oriented, pi\'f9  \b\par
\b0 L\rquote operatore static svincola dall\rquote oggetto in quanto se applicato alle variabili, queste vengono memorizzate le variabili static permettono di definire propriet\'e0 comuni a tutte le istanze della classe  nella method area e non nell\rquote heap, mentre se applicato ai metodi, questi possono essere invocati direttamente dalle classi di appartenenza. L\rquote operatore final invece si traduce in immutabilit\'e0, per cui se applicato agli attributi si ottengono delle costanti, se applicato ai metodi questi diventano NON sovrascrivibili\par
Static:svincola dall'oggetto\par
Attributo: rende l'attributo comune a tutte le istanze della classe (l'attributo \'e8 nella method area) \par
Metodo:pu\'f2 essere richiamato dalle classi che extendono la classe con metodo Static con l\rquote override, se applicato alle classi queste diventano non estendibili. \par
\b 18) Cosa \'e8 una classe Wrapper e per quali motivi nasce?\par
\b0 in una arraylist prendiamo esempio un arraylist quel tipo di strutture non accettano i tipi primitivi si devono inserire solo classi come la classe Boolean per contenere dati primitivi \b\par
\b0 Una classe Wrapper \'e8 una classe che si riferisce ai dati primitivi e nasce per incapsulare un dato primitivo in un oggetto che cos\'ec pu\'f2 essere inserito nelle liste (es.ArrayList) che accettano SOLO gli oggetti. Inoltre, queste classi aggiungono funzionalit\'e0 ai tipi primitivi; un esempio sono i parse, ovvero, i metodi di conversione. Se volessimo ad esempio convertire una stringa in un tipo int, useremmo Integer.parseInt(\ldblquote stringa\rdblquote ), ove Integer \'e8 la classe wrapper riferita al tipo int. Altri esempi di classi wrapper sono: Double, Boolean, ecc. \par
\b 19) Fare un esempio di polimorfismo degli oggetti sia lato upcasting che lato downcasting.\par
\b0 Date due classi: Dipendente e Manager, ove la seconda estende la prima, per effetto dell\rquote Upcasting posso dichiarare l\rquote istanza della classe Manager con il tipo Dipedente (che tra le due \'e8 la classe pi\'f9 generica). Per\ul  \ulnone cui:\par
Dipendente m = new Manager();\par
Ci\'f2 non sorprende in quanto un oggetto di Manager \'e8 anche un dipendente. L\rquote upcasting quindi giustifica perch\'e9 in un metodo, in cui l\rquote argomento \'e8 un tipo Dipendente, \'e8 possibile passare anche l\rquote istanza di Manager. Con il downcasting ci poniamo il seguente problema. Se un metodo ha nella firma un argomento di tipo Dipendente, l\rquote intera implementazione va scritta rispetto questo tipo. Per cui, nel caso in cui passiamo l\rquote istanza di Manager, cosa facciamo? Dobbiamo usare il cast per far capire che all\rquote altezza di una determinata riga pu\'f2 arrivare un manager al posto del semplice dipendente. Per cui se:\par
Dipendente d = new Dipendente(); \par
posso scrivere come segue:\par
((Manager)d).metodoDiUnManager(); -> il cast mi permette di usare il metodo di un tipo pi\'f9 specifico usando\par
l\rquote oggetto di una classe pi\'f9 generica. \par
\b 19bis) Propriet\'e0 dei paradigmi ad oggetti\par
\b0 ha tre propriet\'e0\par
\b Polimorfismo\b0 , Ordine\par
\b Ereditariet\'e0\b0 , Riuso\par
ed \b Incapsulamento\b0  Sicurezza\par
\par
incapsulamento serve per definire la scrittura e la lettura dell'accesso di una classe \par
\'e8 la propriet\'e0 di nascondere attributi di una classe ad un'altra classe dove si rendono disponibili tramite metodi pubblici (getter and setter) le variabili private all'interno della classe  \par
poliformismo si ripartisce in poliformismo di metodi e quello degli oggetti\par
abbiamo per gli oggetti upcasting e downcasting\par
invece per i metodi Overload e Override\par
il codice  \'e8 pi\'f9 ordinato  e lo possiamo dividere in componenti\par
Poliformismo dei metodi \par
Overload\par
Propriet\'e0 di usare la stessa firma del metodo ma con diversi argomenti.\par
Override= strettamente legato ad ereditariet\'e0 che sovrascrive i metodi della classe che eredita dalla superclasse;\par
Upcasting= permette di istanziare un oggetto specifico dichiarandolo con la classe generica\par

\pard\sa200\sl276\slmult1\qc Downcasting= si esegue una forzatura  istanziando con una classe pi\'f9 generica castando con la classe e richiamando il metodo pi\'f9 specifico ;\par

\pard\sa200\sl276\slmult1\par
\b\par
20) Cosa \'e8 instanceof e si faccia un esempio del suo utilizzo.\par
\b0 Instanceof consente di riconoscere il tipo dell\rquote oggetto passato ad un metodo. Esempio:\par
public void riconosciIstanza(Dipendente d)\{\par
 if(d instanceof Manager)\par
 System.out.print(\ldblquote L\rquote oggetto appartiene alla classe Manager\rdblquote );\par
 else\par
 System.out.print(\ldblquote L\rquote oggetto appartiene alla classe Dipendente\rdblquote );\par
\}\par
\b 21) Si illustri la gerarchia delle Collections.\par
\b0 Le strutture dinamiche List hanno memoria dell\rquote inserimento fatto e per tanto ammettono dati duplicati; le strutture Set vedono HashSet non riconoscere l\rquote ordine degli inserimenti ed elimina i duplicati, mentre LinkedHashSet mantiene l\rquote ordine degli inserimenti ma elimina i duplicati. Queue indica consente la gestione delle pile e delle code; la pila segue la politica LIFO (Last Input First Output), ovvero, l\rquote ultimo dato ad entrare \'e8 la testa, ma questo \'e8 anche il primo ad uscire (es. pila di piatti); la coda segue la politica FIFO (First Input First Output) ove il primo dato inserito \'e8 il primo ad essere letto (es. tangenziale -> il primo che arriva al casello \'e8 il primo ad uscire da quest\rquote ultimo). LinkedList implementando sia List che Queue si avvale sia dei metodi di un ArrayList che quelli delle politiche LIFO e FIFO. \par
\b 22) Cosa sono le eccezioni? In che modo le gestisco ed in che modo posso delegare la loro gestione?\b0\par
la classe exception \'e8 la superclasse di tutti quegli errori logici, ci sono problemi di incoerenza logica,NumberFormatException(); questo \'e8 un esempio di classe che estende Exception.\par
Arithmetic Exception se faccio 1/0 \'e8 impossibile se stiamo gestendo un rapporto che passi tu\par
ArrayOutBoundException dove superi la dimensione dell'array/vettore.\par
abbiamo modo di catturare una eccezione cos\'ec da non far crashare il programma e continuarne l'esecuzione\par
le eccezioni sono classi a tutti gli effetti;\b\par
\b0 Sono errori di logica; quando attivate mandano in crash il sofware. E\rquote  possibile gestirle col try-catch; il try \'e8 il blocco che mette in quarantena le righe suscettibili ad eccezione, mentre il catch cattura l\rquote eccezione prevista e risponde all\rquote errore con le istruzioni del suo blocco. Poich\'e9 il try pu\'f2 contenere una grossa mole di righe, possono essere vari i potenziali errori, per tanto si usa disporre pi\'f9 catch a cascata mettendo per primi quelli  degli errori noti (cos\'ec da gestirli nei casi specifici), fino a tamponare il tutto con un ultimo catch che \'e8 quello che cattura l\rquote eccezione pi\'f9 generica: l\rquote Exception. Nel caso in cui si volesse delegare la gestione di una eccezione ad una classe chiamante, si usa la keyword throws applicata al metodo da tenere sotto controllo. Sar\'e0 preoccupazione della classe chiamante gestire il metodo con un try-catch o delegarlo a sua volta alle potenziali classi interessate.\par
\b 23) Si nomini la superclasse delle eccezioni.\par
\b0 Exception, a sua volta figlia della superclasse Throwable. \par
\b 24) Cosa \'e8 l\rquote ereditariet\'e0? Dove influisce nel paradigma OO?\par
\b0 E\rquote  la propriet\'e0 di riuso del codice mediante una relazione padre-figlio tra classi ed interfacce. L\rquote ereditariet\'e0 si ripercuote nell\rquote incapsulamento, in particolar modo sul modificatore d\rquote accesso protected (sarebbe identico al default se non fosse per il fatto che in caso di ereditariet\'e0 due classi di package diversi risultano comunque visibili tra loro). Si ripercuote anche nel polimorfismo: nell\rquote override nel caso dei metodi e nell\rquote upcasting e downcasting nel caso degli oggetti. \par
\b 25) Come creo un\rquote eccezione personalizzata?\par
\b0 Creando una classe che estende Exception, all\rquote interno della quale, usando il metodo super() (costruttore di Exception) possiamo stampare il messaggio dell\rquote errore personalizzato. \par
\b 26) Qual \'e8 l\rquote eccezione innescata quando il driver del db non viene caricato?\par
\b0 ClassNotFoundException generato in corrispondenza della riga: Class.forName(). Questa eccezione riporta che il driver relativo al DBMS (Database Management System) non \'e8 stato trovato/riconosciuto.\par
\b 27) Qual \'e8 la porta usata per mysql? Si faccia una ricerca per quelle di Oracle e MS SQL Server.\par
\b0 La porta MySql \'e8 la 3306, in Oracle \'e8 la 1521, in MS Sql Server 1433.\par
\b 28) Per motivi di sicurezza si preferisce l\rquote interfaccia PreparedStatement a quella Statement ma quali sono\par
gli altri vantaggi della prima rispetto la seconda?\par
\b0 Il tipo PreparedStatament consente l\rquote uso dei parametri ? che evita la difficile gestione delle concatenazioni (obbligatorie nel caso dello Statement), oltre ad occultare i dati, migliorando quindi la sicurezza. Inoltre precompila il comando sql prima della sua esecuzione.\par
\b 29) Differenze tra i metodi: next() e first(). (Metodi dell\rquote oggetto di tipo ResultSet).\par
\b0 L\rquote iteratore next() itera un ciclo while tante volte per quante sono le righe di una select; l\rquote ultima iterazione si ferma sull\rquote ultima riga individuata. first() invece punta solo alla prima riga trovata. \par
\b 30) Quali sono i tipi di Servlet? E i tipi di richiesta? Scrivere nel dettaglio.\par
\b0 Una Servlet pu\'f2 essere o una classe Java che si comporta da Controller o una pagina JSP (JavaServer Pages); invece i tipi di request sono: get se la richiesta viene fatta con una querystring e post se viene fatta con un form. Il method get \'e8 meno sicuro perch\'e9 i dati non vengono occultati ma letti su url; di contro il method post \'e8 sicuro perch\'e9 nasconde i dati.\par
\b 31) Come si fa il Crud con un ArrayList?\par
\b0 Il Create lo si fa col metodo add(), il Read col metodo get(), l\rquote Update col metodo set() ed il Delete col metodo remove().\par
\b 32) Come si fa il Crud con sql?\par
\b0 Con i comandi DML (Data Manipulation Language) facciamo Insert (Create), Update (Update) ed il Delete (Delete). Con la select DQL (Data query Language) facciamo il Read.\par
\b 33) Differenze tra vettore e ArrayList.\par
\b0 Un vettore \'e8 una struttura dati statica, mentre un ArrayList \'e8 una struttura dati dinamica. Un vettore si dice statico in quanto ha una dimensione fissata, leggibile con l\rquote ATTRIBUTO lenght; una lista invece si dice dinamica in quanto ha una dimensione variabile in funzione di aggiunte e cancellazioni; la dimensione di una lista viene recuperata dal metodo size():\par
\b 34) Differenza tra firma e dichiarazione di un metodo\par
\b0 La firma \'e8 composta dal nome del metodo e dall\rquote argomento passato, mentre la dichiarazione comprende\par
anche il modificatore d\rquote accesso, eventuali operatori (es. abstract, final, static) ed il tipo di dato ritornato.\par
\b 35) Cos\rquote\'e8 l\rquote orm?\par
\b0 E\rquote  una propriet\'e0 dell\rquote Object Oriented che consente di:\par
1)Creare in automatico le tabelle di un db a partire dal mapping di una classe, usando le annotation @Entity\par
e @Table(name="nome_tabella");\par
2)Creare colonne della tabella a partire dagli attributi della classe, usando l\rquote annotation @Column (@Id per\par
specificare il campo che si comporta da Primary Key o pk);\par
3)Creare righe della tabella a partire dagli oggetti che si mappano con le annotation: @OneToOne,\par
@OneToMany/@ManyToOne e @ManyToMany\par
La specifica Java per applicare l\rquote ORM \'e8 la libreria JPA (Java Persistance Api). \par
\b 36) Volendo compilare un programma scritto sul blocco notes, quali sono i due comandi che chiamiamo\par
dal prompt dei comandi?\par
\b0 javac per tradurre il codice sorgente (Java nel nostro caso) in bytecode e java per eseguire il bytecode.\par
\b 37) Cosa intendiamo con a++ e ++a?\par
\b0 Nel primo caso intendiamo un post-incremento, quindi in una stampa vedremmo il numero non ancora\par
incrementato e solo dopo avverr\'e0 l\rquote incremento, nel secondo caso abbiamo un pre-incremento dove ci viene\par
stampato il valore gi\'e0 incrementato.\par
\b 38) Cosa sono super e super()?\par
\b0 super \'e8 la keyword che si riferisce alla superclasse quando di un metodo ereditato si vuole fare un override\par
conservando il codice originale. Esempio:\par
@Override\par
void toString()\{\par
return super.toString()+\rdblquote  nuova pezzo\rdblquote ; //recupero il codice del metodo ereditato e gli aggiungo un pezzo\par
\}\par
super() invece si riferisce al costruttore della superclasse ed \'e8 presente all\rquote interno del costruttore di una\par
classe derivata.\par
\b 39) Cosa \'e8 lo scope di una variabile?\par
\b0 E\rquote  la visibilit\'e0 contestuale di una variabile. Una variabile globale \'e8 visibile ovunque, nella classe e nei metodi\par
di quest\rquote ultima; una variabile locale \'e8 visibile solo nel blocco di implementazione dei metodi. La visibilit\'e0 \'e8\par
contestuale anche dei blocchi delle strutture condizionali e dei cicli; quindi, una variabile dichiarata\par
nell\rquote implementazione di un ciclo \'e8 visibile solo nel suo interno.\par
\b 40) Cosa si intende per passaggio per valore e per riferimento? Ci facciano degli esempi con lo swap o scambio.\b0\par
Col passaggio per valore passiamo in un metodo la copia di un dato e per tanto, quello che accade su esso\par
non si ripercuote sulla variabile vera e propria. Nel passaggio per riferimento, un metodo prende la copia del\par
riferimento di un oggetto; tuttavia, per quanto copia, questa punta la porzione della heap memory dedicata\par
all\rquote oggetto ed agendo su questa, le modifiche rimangono permanenti.\par
Il passaggio per valori lo si fa con variabili primitive;\par
ma in realt\'e0 passaggi per valori non passo una variabile originale ma una copia.\par
passaggio per riferimento passa direttamente l'indirizzo e la variabile originale non subisce ripercussioni\par
\par
\b 41) Cosa sono HTML e Css?\par
\b0 HyperText Markup Language \'e8 un linguaggio di markup, ovvero, strutturato in marker detti tag. Questi tag\par
vengono presi da una libreria (API) di Html detta Dom. Html nasce per la formattazione e impaginazione di\par
documenti ipertestuali disponibili nel web, costruisce il layout di una pagina web usando tag specifici. Il Css \par
Domande colloquio (Aggiornato al 7 aprile 2020)\par
P a g . 10 | 14\par
(Cascading Style Sheets, ovvero, fogli di stile a cascata) \'e8 un linguaggio usato per definire la formattazione di\par
documenti HTML, XHTML e XML, nello specifico, consente di associare con delle propriet\'e0 una veste grafica\par
a tali documenti. Col Css possiamo definire una classe (indicato col \ldblquote .\rdblquote  in Css, e come propriet\'e0 class in Html),\par
ovvero, un insieme di propriet\'e0 comuni a pi\'f9 elementi html, oppure, un id (indicato con \ldblquote #\rdblquote  in css e come\par
propriet\'e0 id in html) se vogliamo associare propriet\'e0 esclusive ad un unico elemento html.\par
Nb: Html e Css NON sono linguaggi di programmazione ma di formattazione del testo.\par
\b 42) Cosa \'e8 Javascript?\par
\b0 E\rquote  un linguaggio di scripting, ovvero, un linguaggio con compilato ma direttamente interpretato. Quindi viene\par
eseguito direttamente il codice sorgente. E\rquote  un linguaggio orientato agli eventi.\par
\b 43) Cosa \'e8 jQuery? Come cambia Javascript? Si faccia un esempio sull\rquote evento: onclick.\par
\b0 JQuery \'e8 un framework Javascript; oltre ad introdurre metodi che generano effetti grafici (es. hide(), show(),\par
fadeIn(), fadeOut, ecc.), rende pi\'f9 snello il codice. Volendo fare un esempio sull\rquote evento onclick, se la forma\par
Javascript era:\par
document.getElementById("id_div1").onclick=function()\{\'85\}\par
con jQuery la stessa riga diventa:\par
$(" id_div1").click(function()\{\'85\}\par
\b 44) Cosa \'e8 BootStrap?\par
\b0 E\rquote  un framework Html, Css e Javascript.\par
\b 45) Quali sono le clausole usate in una select? Si faccia un esempio per ognuna.\par
\b0 select nome from utenti where id=1;\par
select * from utenti orderby nome;\par
select * from utenti groupby nome;\b\par
46) Cosa \'e8 JSTL? Con quali tag \'e8 possibile implementare una struttura condizionale in una pagina JSP?\par
47) Cosa \'e8 JDBC? Per cosa sta il suo acronimo?\par
\b0 le viste sono join permanenti \par
avresti bisogno sempre della stessa, join, \par
lo schema del database skima\par
\'e8 una libreria di classi java,\par
JDBC = Java Database Connectivity\par
ci consente di connetterci ad un database manipolarlo e aggiornarlo ed interrogarlo ma non crearlo\par
\par
\'e8 un driver, ogni dbms ha un driver, usiamo mysql come dbms, e il nostro driver mysql \b\par
\b0 JDBC= Java DataBase Connectivity \par
non si possono fare ddl ma solo dml e dql\par
per stabilire una connessione o la chiusura dello stesso uso Connection \par
dml-> Statement e preparedStaement\par
lo Statement mi obbliga a fare una concatenazione di campi cosa difficoltosa quando  ci sono tanti campi\par
il PreparedStatement ci facilita il lavoro grazie al parametro ?\par
ps consente di precompilare un comando sql \par
Statement stm =conn.createStatement();\par
stm.executeUpdate("comando sql");\par
\par
PreparedStatement ps = conn.prepareStatement ("comando sql con ?")\par
ps.petString (pos del ? , paremetro)\par
ps.setInt\par
ps.executeUpdate();\par
\b\par
48) Si esplicitino i legami tra i vari oggetti presi da JDBC.\par
\b0 Elenco delle librerie jdbc\par
1. Connection\par
con la classe connection ci permette di connetterci al database\par
2.Statement\par
3.PreparedStatement\par
fanno il dml ovvero insert update e delete ma il preparedstatement la fa meglio\par
ResultSet\par
faremo la select\par
gli oggetti di queste classi sono relazionate tra loro: gli oggetti di tipo statement e preparedStatement, dipendono dall'oggetto di tipo connection\par
l'oggetto di tipo resultset dipende o dall'oggetto di tipo preparedstament o  dall'oggetto statement.\par
tutte le classi statement obbligano il try catch, sono tutte Throws, \par
Connection=\par
gli oggetti JDBC non si istanziano mai con i costruttori\par
\par
open connection \par
e close connection devono essere usati sempre all'inizio di un metodo crud e alla fine di un metodo crud\par
\par
ritorner\'e0 sempre il solito riferimento\par
per ogni crud si deve sempre aprire e chiudere la connessione ogni volta che fai un comando per il database \par
non dobbiamo permettere di creare potenziali oggetti simili ma non servono.\par
Statement e Prepared Statement mi consentono la dml\par
\par
il read te lo fa fare il select il dql\par
ce lo fa fare il result set  \par
Connection apre e chiude la connessione\par
\par
questi oggetti non si istanziano con il costruttore perch\'e8 tra loro ci sono dei legami, io per poter istanziare lo statement questo mi comprende \par
\par
il result set dipende o dallo statemente o il preparaedstament\par
metto in memoria rs e poi faccio partire la query\par
essendoci un legame tra loro sono dipendenti da essi \par
quindi cosa significa se questo dipende da questo, \par
\par
senn\'f2 il result set prenderebbe uno dei due statment nulli \par
usiao il preparaed statement se non avessi richiamato il metodo Prpeparaed statment con la dipendenza di connection,conn sar\'e0 l'unico oggetto ritornato dalla classe utility.\par
true false \par
\par
\par
\b\par
49) L\rquote acronimo di HTML, Css, Jsp e Jstl.\par
\b0 HyperText Markup Language; Cascading Style Sheets; JavaServer Pages; JavaServer Pages Standard Tag\par
Library.\par
\b 50) Si descriva la gestione della memoria da parte della JVM.\par
\b0 La JVM gestisce una porzione di memoria ram dedicata al software. In runtime, la jvm gestisce: una method\par
area per memorizzare classi, variabili statiche e blocchi statici; una heap memory per allocare gli oggetti (per tanto comprende il pool di stringhe) e le relative variabili di istanza; ed una pila stack in cui sono contenuti i\par
metodi e le variabili locali.\par
Di questa porzione di area ram  la JVM la ripartisce in 3 parti\par
fa una ripartizione \par
\par
blocchi statici/variabili statici/referenze\par
Method= gestisce le classi \par
heap=  gestisce gli oggetti le variabili di istanza\par
stack= memorie gestisce la memoria.\par
\par
quando viene eseguito il bytecode runtime, la jvm gestisce la memoria ram\par
\par
in una classe andiamo a dichiarare le variabili di istanza \par
le variabili statiche rimangono nella method area, quella di istanza vanno nell'heap\par
i metodi statici e non statici comprese le loro variabili locali vanno nello stack dal basso verso l'alto\par
nell'heap area c'\'e8 una piccola parte chiamata pool di stringhe dove ci saranno le stringhe\par
\par
se il primo metodo \'e8 main  e poi c'\'e8 il metodo pinomauro, il primo metodo \par
il metodo main \'e8 statico perch\'e8 per essere chiamato non devi richiamare il metodo, \par
perch\'e8 sarebbe Controller.main.\par
nella memoria heap sono allocati tutti gli oggetti, quando creiamo un costruttore col new indirizziamo l'oggetto nell'heap, ora ci sono casi in cui un oggetto perde il riferimento per esempio quando dici oggetto a e oggetto b e fai a=b cos\'ec sovrascrivi l'indirizzo di riferimento di a in a in memoria.\par
quando uno dei due perde riferimento dell'indirizzo l'operatore automatico   GarbageCollection automaticamente cancella l'indirizzo dall'heap  in memoria perch\'e8 \'e8 inutile\par
method area e heap sono memorie statiche, la parte dinamiche  \'e8 stack che gestisce i metodi in ordine di pila che parte dal main e va dal basso verso l'alto nello stack ma nella classe partir\'e0 dall'alto dal main verso il basso \par
il vettore \'e8 un oggetto;\par
\par
\b 51) Quando clicchiamo sul run di Eclipse, quali comandi vengono eseguiti?\par
\b0 Javac per compilare, ovvero, tradurre il codice sorgente contenuto nel file.java in bytecode in un file.class e\par
java, per eseguire il file.class.\par
\b 52) Perch\'e9 il metodo main() \'e8 statico?\par
\b0 Perch\'e9 il comando java chiama Controller.main() se Controller \'e8 la classe che contiene il metodo main(). Si\par
dice che il main \ldblquote si chiami da solo\rdblquote  per essere il punto di partenza, lo starter, dell\rquote esecuzione del\par
programma Java Standard Edition.\par
\b 53) Un ArrayList pu\'f2 accettare tipi primitivi?\par
\b0 No, ed \'e8 questo il motivo per cui nascono le classi wrapper. Un oggetto di tipo wrapper incapsula dentro di\par
se il tipo primitivo, cos\'ec da renderlo archiviabile in una lista.\par
\b 54) Cosa sono gli oggetti simili?\par
\b0 Sono oggetti di classi legate da ereditariet\'e0 o oggetti di classi che implementano la stessa interfaccia.\par
\b 55) I metodi toString() ed equals() da quale classe vengono ereditati e cosa fanno nella loro forma\par
originale?\par
\b0 I due metodi appartengono alla classe Object, la superclasse di tutte le classi Java. toString() ritorna come\par
stringa il riferimento di un oggetto, mentre equals() confronta l\rquote indirizzo di due oggetti ritornando un valore\par
booleano (true in caso di uguaglianza verificata).\par
\b 56) Cosa accade nel pool di stringhe?\par
\b0 Oggetti stringa con lo stesso dato vengono ricondotti ad un unico oggetto.\par
Se ad esempio dichiariamo:\par
String s1 = \ldblquote pippo\rdblquote ;\par
String s2 = \ldblquote pi\rdblquote +\rdblquote ppo\rdblquote ;\par
String s3 = \ldblquote p\rdblquote +\rdblquote ippo\rdblquote ;\par
e facessimo i seguenti controlli:\par
System.out.print(s1==s2); \par
Domande colloquio (Aggiornato al 7 aprile 2020)\par
System.out.print(s1==s3);\par
avremmo in output: true, in entrambi i casi.\par
Per avere due oggetti di tipo String con lo stesso dato dobbiamo forzare la cosa con new+costruttore:\par
String s4 = new String(\ldblquote pippo\rdblquote );\par
System.out.print(s1==s4); -> Ora ci darebbe false perch\'e9 i due oggetti vengono ora distinti\par
Il new+costruttore genera sempre un nuovo riferimento!\par
\b 57) Con quale oggetto arriva in una servlet Controller il contenuto di un form?\par
\b0 Con l\rquote oggetto di tipo HttpServletRequest che prende i parametri o dal form o da una querystring.\par
\b 58) Con quali righe di codice \'e8 possibile passare i parametri da una servlet controller ad una pagina jsp?\par
\b0 request.getParameter(\ldblquote name\rdblquote );\par
RequestDispatcher rd = request.getRequestDispatcher(\ldblquote path.jsp\rdblquote );\par
rd.forward(request,response);\par
\b 59) Differenza tra una pagina Html ed una Jsp.\par
\b0 Una pagina Html consente solo il passaggio dei parametri ad una Servlet controller o ad una jsp, mentre\par
appunto una jsp pu\'f2 anche riceverli.\par
\b 60) Si conti da 1 a 20 escludendo i numeri dispari; poi, si conti da 1 a 10 triplicando i numeri pari. Con una struttura condizionale si permetta di scegliere uno dei due cicli.\par
61) Ciclo di vita di una Servlet (classe Controller)\par
\b0 Il ciclo di vita di una Servlet \'e8 definito dai metodi: init(), service() e destroy(), presenti di default in una classe\par
Servlet. Il metodo init() \'e8 un metodo che inizializza la servlet se riempito con delle righe di codice, altrimenti\par
non ha alcuna funzionalit\'e0; ad esempio, se invece di effettuare una connessione al database si volesse fare\par
la persistenza su file, nel metodo init() andremmo a caricare il file su cui scrivere i dati da archiviare. Il metodo\par
service() consente la comunicazione client-server prendendo in ingresso gli oggetti HttpServletRequest ed\par
HttpServletResponse. Se la servlet estende la classe HttpServlet, service() delega la richiesta ricevuta dal\par
client ai metodi doPost() e doGet(). Infine, il metodo destroy() si preoccupa di rimuovere dalla memoria la\par
servlet non appena il metodo service() o quelli doPost() e doGet() terminano la loro esecuzione. Con il\par
destroy() possiamo effettuare il salvataggio su file (SE facciamo la persistenza su file) prima di liberare la\par
memoria. \par
Domande colloquio (Aggiornato al 7 aprile 2020)\par
\par
\b 62) Cosa sono gli scriptlets in una pagina Jsp?\par
\b0 Sono una tipologia degli scripting elements (noi abbiamo usato quelli Jstl core), ovvero, tag Html che\par
contengono istruzioni proprie del linguaggio Java. Ogni istruzione Java pu\'f2 essere utilizzata in uno scriptlet,\par
la cui forma generale \'e8: <% codice Java %>. Ad esempio, per ripetere la frase \ldblquote Ciao Mondo!\rdblquote  per 5 volte nella\par
pagina di output, sar\'e0 possibile utilizzare il seguente scriptlet:\par
<%\par
 for (int i = 0; i < 5; i++)\par
 \{\par
%>\par
Ciao Mondo!\par
<%\par
 \}\par
%>\par
\b 63) Cosa sono i Thread?\par
\b0 Un thread \'e8 un singolo flusso sequenziale di istruzioni; nasce dal bisogno di attivare pi\'f9 operazioni in parallelo\par
all\rquote interno dello stesso programma. Se immaginiamo un insieme di thread come una serie di programmi\par
individuali in un unico software, abbiamo il multithreading e quindi la capacit\'e0 della nostra applicazione nel\par
gestire pi\'f9 operazioni in parallelo. Ogni thread, essendo un processo indipendente, ha la sua pila stack ed \'e8\par
per questo che non deve attendere la conclusione dei metodi avviati da altri processi, ma solo quella dei suoi;\par
tuttavia, i thread condividono lo stesso spazio di indirizzamento, ovvero, la stessa area di memoria riservata\par
all\rquote applicazione effettiva. Condividendo lo stesso spazio possono entrare in concorrenza nell\rquote uso di oggetti\par
che appartengono a classi diverse dai thread. Facciamo un esempio sfruttando il pattern Singleton. Il metodo\par
getInstance() che ritorna l\rquote unica istanza potrebbe essere invocato in ogni singolo thread; nello stesso\par
programma avremmo quindi l\rquote assurdo di ritrovare l\rquote unica istanza chiamata pi\'f9 volte in parallelo. Per evitare\par
conflitti, basta battezzare un metodo come synchronized. In questo modo quel metodo potr\'e0 essere usato\par
solo da un thread alla volta e nel caso del Singleton, l\rquote oggetto sar\'e0 gestito solo da un thread alla volta.\par
\b 64) Differenza tra multitasking e multithreading\par
\b0 Il multitasking \'e8 la molteplicit\'e0 dei software che lavorano in contemporanea (si immagini la gestione attivit\'e0\par
di Windows) in un unico sistema operativo; il multithreading \'e8 l\rquote insieme delle attivit\'e0 interne allo stesso\par
software.\par
\b 65) Quali sono le modalit\'e0 per implementare un thread?\par
\b0 Due. Un thread pu\'f2 essere istanziato o con una classe che estende quella Thread, o istanziato da una classe\par
che implementa l\rquote interfaccia Runnable. L\rquote oggetto che estende la classe Thread deve chiamare il metodo\par
start() per invocare il metodo run() che esegue il flusso sequenziale; l\rquote oggetto che implementa Runnable deve\par
invece invocare direttamente il run() per attivare un flusso sequenziale.\par
Domande colloquio (Aggiornato al 7 aprile 2020)\par
P a g . 14 | 14\par
\b 66) Che vantaggi da l\rquote implementazione dell\rquote interfaccia Runnable?\par
\b0 La maggiore flessibilit\'e0 derivante dal poter essere sottoclasse di qualsiasi altra classe e non unicamente della\par
super classe Thread.\par
\b 67) Cosa sono i Cookie?\par
\b0 Un cookie \'e8 una stringa di nome session_id che viene associata al client quando questo fa una richiesta http\par
al server. Quindi, a richiesta giunta, il server genera l\rquote id_session da associare all\rquote utente e se lo salva in\par
memoria, poi invia la response (una pagina web) al client, inserendo nell\rquote header della pagina di risposta la\par
session_id; Il browser del client, dopo aver ricevuto la risposta, salver\'e0 il cookie nella propria memoria. Nelle\par
successive richieste, il client rinvia al server lo stesso cookie in modo che il server riconosca l\rquote utente\par
confrontandolo con l\rquote id_session salvato in memoria. Possiamo ricapitolare il tutto nei seguenti step:\par
Step 1: il client invia una richiesta al server\par
Step 2: Il server genera il cookie con session_id annesso e se lo salva in memoria per successivi confronti\par
Step 3: Il server invia una risposta (una pagina web) col cookie (e session_id) al client\par
Step 4: Il browser del client salva il cookie nella propria memoria\par
Step 5: il client manda una nuova richiesta al server rinviandogli il cookie\par
Step 6: Il server controlla se il cookie giunto gli risulta in memoria cos\'ec da riconoscere l\rquote utente che ha fatto la\par
nuova richiesta\par
\b 68) Come si elimina una sessione?\par
\b0 Si istanzia l\rquote oggetto di tipo HttpSession con cui si invoca il metodo invalidate(). Questo metodo rimuove dalla\par
memoria l\rquote id_session memorizzato dal browser effettuando cos\'ec un LogOut. \par
\b 69) Creare una impaginazione\par
\b0 Impaginazione di 3 Dipendenti per Pagina\par
immaginiamo di usare un unico arraylist dove posso spezzettarlo in liste\par
in funzione della pagina dividiamo per eccesso le pagine \par
usando un solo arraylist mi serve un ciclo for  usando le delle variabili per definizione che sono le keyword offset e limit\par
per offset, si parla di limite inferiore \'e8 la prima cella di ripartizione per ripartire dati che potrebbero essere stampati insieme. \par
il limit \'e8 la cella da escludere \par
int pagina=1;\par
int totalepagine=0;\par
if(totaledipendentie%dipendentistamp==0)\par
totpagine=totale dipendenti/dipendenti stampati\par
else\par
tot pag=totaledipendenti/dipendentistampati+1\par
offset= (pagina-1)*dipendentixpagina\par
limit=offset+dipendentistampxpag\par
i<limit&&i<size\par
una select che recupera titoli e permessi  dove posso inserire elementi che mi serviranno per riempire le mie pagine\par
\b che mi serve la referenced libraries?  \'e8 dove vengono contenute le librerie delle servlet \par
\b0 Bonus1: con Java 8  le interfacce hanno anche metodi di default e metodi statici entrambi con implementazioni \par
con Java 9 hanno anche metodi privati\par
\b 4) Quali tipi di servlet Conosci? \par
\b0 Classi Controller e jsp (java server pages - pagina dinamica)\par
con le servlet grazie ai metodi doPost e doGet hanno preso il posto delle metodo main per la l'esecuzione della logica dell'applicativo, utilizzando due oggetti di tipo HttpServletResponse e HttpServletRequest verranno istanziati all'interno del web server(tomCat), per essere processati ed eseguiti\par
quando si parla di servlet si parla anche di jsp \par
perch\'e8 hanno tutte una logica, quali tipi di servlet conosci? jsp e le classi servlet che effettuano la logica\par
spring simula le servlet\par
\par
\b Qualit tipo di request conosci? get queryString e post-> form\par
Cosa sono gli oggetti simili?\par
\b0 le classe simili sono anche quelle che implementano la stessa interfaccia.\b\par
\b0 1- oggetti che appartengono a classi legate da eredit\'e0 \par
2- quando implementano la stessa interfaccia\par
LinkedList implementa due interfaccie che sono List e Queue\par
grazie a questa ereditariet\'e0  avr\'e0 metodi  di list ma anche di queue \par
come adFirst(Object o) e addLast(Object o)\par
List<Dipendente> lista=new ArrayList<>();\par
si parla di tutti i modificatori di accesso \par
solo l'override \'e8 influenzato da ereditariet\'e0, anche downcasting e upcasting\par
\par
\b 9)vettore di interi \par
\b0 int[] v =new int [5]\par
for (int i; i<v.length;i++) \{\} lenght \'e8 un attributo dell'oggetto vettore\par
invece per le stringhe Stringa.length(); \'e8 un metodo diverso dall'attributo lenght perch\'e8 vede la lunghezza della stringa\par
il vettore \'e8 una struttura statica  non puoi togliere celle, la grandezza rimane tale\par
List<Dipendente> lista =new ArrayList<>();\par
for (int j=0;j<lista.size();j++)\{\} size \'e8 un metodo che prende la grandezza della grandezza corrente dato che le list sono una struttura dati dinamica e quindi cresce in base a quello che aggiungi durante l'inserimento\par
\par
8) Che cos'\'e8 Incapsulamento\par
E' la proprit\'e0 del linguaggi ad Oggetti di nascondere gli elementi di una classe attraverso l'uso dei modificatori di accesso\par
\par
Quali sono i modificatori di accesso in Java (I modificatori di accesso si possono applicare solo agli attributi)\par
1)public\par
2)private\par
3)protect\par
4)default. La parola chiave default non esiste, se non si indica nessun modificatore allora vale default. Ex. int a;\par
\par
Quando descrivete i modificatori di accesso ricordate che la visibilit\'e0 pu\'f2 essere regolata nei seguenti casi:\par
1) Istanza (new)\par
2) Ereditariet\'e0 (extends)\par
3) Le classi possono essere nello stesso package oppure in package diversi\par
\par
9) Che cos'\'e8 l'Ereditariet\'e0\par
E' una tecnica di riuso del codice. La classe ereditata si chiama padre, quella che erdita si chiama figlia. La parola chiave per ereditare e extends.\par
In Java l'ereditariet\'e0 \'e8 singola, si pu\'f2 ereditare una sola classe per volta.\par
La classe figlia \'e8 detta anche classe specializzata.\par
\par
--> Spiegare la tecnica di gestione del costruttore parametrizzato (super()).\par
\par
10) Che cos'\'e8 il polimorfismo\par
1) Polimorfismo dei metodi: Overload/Override\par
2) Polimorfismo degli oggetti: Polimorfismo per Eredit\'e0 e per Interfaccia\par
\par
11) Che cos'\'e8 l'Overload\par
L'Overload \'e8 la propriet\'e0 dei linguaggio ad oggetti che ti permette in inserire nella stessa classe metodi con lo stesso nome ma firma diversa:\par
public Colora\{\par
   public void colora(int colore)\{\par
   ...\par
   \}\par
\par
   public void colora(String colore)\{\par
   ...\par
   \}\par
\par
   public void colora(int r,int g, int b)\{\par
   ...\par
   \}\par
\}\par
\par
12) Che cos'\'e8 la firma:\par
nome del metodo + tipi di argomenti, ad esempio:\par
1)  public void colora(int colore) la firma \'e8 colora int\par
2)  public void colora(String colore) la firma \'e8 colora String\par
3)  public void colora(int r,int g, int b) la firma \'e8 colora int int int\par
\par
13) Che cos'\'e8 l'Override\par
L'Override si applica solo nel caso dell'Ereditariet\'e0, serve a cambiare il comportmanto di un metodo ereditato, sovrascrivendolo.\par
I metodi ereditati e sovrascritti hanno all'inizio l'annotazione @Override\par
\par
14) Che cos'\'e8 il Polimorfismo degli oggetti per ereditariet\'e0\par
Due oggetti sono simili quando si ereditano tra loro.\par
public class Persona extends Object\{\par
...\par
\}\par
\par
public class Dipendente extends Persona \{\par
...\par
\}\par
\par
public stampa(Persona p)\{   \par
...\par
\}\par
\par
Persona p=new Persona();\par
Dipendente d=new Dipendete();\par
stampa(p);\par
stampa(d); //Down-Casting     (Argomento)Persona p=d (Valore di tipo Dipendente)\par
\par
Up-Casting\par
if(p instanceof Dipendete)\{\par
Dipendente d=(Dipendente)p;\par
\}\par
\par
15) Che cos'\'e8 il Polimorfismo degli oggetti per interfaccia\par
Due oggetti sono simili quando implementano la stessa interfaccia.\par
\par
public class ArrayList implements List\{\par
...\par
\}\par
\par
public class LinkedList implements List\{\par
...\par
\}\par
\par
public stampa(List l)\{   \par
...\par
\}\par
\par
ArrayList al=new ArrayList();\par
LinkedList ll=new LInkedList();\par
\par
stampa(al);\par
stampa(ll);\par
\par
16) Che cos'\'e8 un'interfaccia\par
Un'intrefaccia \'e8 una struttura di programmazione che pu\'f2 essere implementata in una classe.\par
Contiene metodi abstract (astratti/modello) e costanti.\par
\par
Ad esempio \par
public interface IFigureGeometriche\{\par
int PIGRECO=3.14;\par
public double getPerimetro(FiguraGeometrica fg); //metodo astratto\par
public double getArea(FiguraGeometrica fg); //metodo astratto\par
\} \par
L'interfaccia quando viene implementata in una classe con implements il programmatore deve implementare obbligatoriamente tutti i\par
metodi dell'interfaccia, utilizzando l'annotazione @Override. Quindi l'interfaccia \'e8 un modello.\par
\par
Le interfacce possono essere implementate dalle classe, ma si possono eseditare tra loro.\par
\par
public interface IFigureGeometricheFiglia extends IFigureGeometriche\{\par
...\par
\}\par
\par
17) Che cos'\'e8 una classe astratta\par
E' un pattern (soluzione) risolvono il problema di poter implementare metodi che usano altri metodi di cui non consciamo il comportamento.\par
Una classe astratta \'e8 una classe che contiene almeno un metodo abstract(astratto/modello).\par
Le classe abstract non possono istanziare oggetti, ma vanno necessariamente ereditate e la classe figlia dovr\'e0 implementare i metodi abstract.\par
\par
public abstract FigureGeometriche\{\par
public String getInfo()\{\par
       return "Perimentro:"+getPerimetro()+" ,Area:"+getArea();\par
\}\par
public abstract double getPerimetro();\par
public abstract double getArea();\par
\}\par
\par
public class Quadrato extends FigureGeometriche\{\par
private int lato;\par
//setter and getter\par
@Override\par
public abstract double getPerimetro()\{\par
       return lato*4;\par
\}\par
public abstract double getArea()\{\par
       return lato*lato;\par
\}\par
public Quadrato()\{\}\par
public Quadrato(int lato)\{\par
super();\par
this.lato=lato;\par
\}\par
\}\par
\par
18) Operatore final\par
\par
a) Nella dichiarazione di un attributo, in questo caso l'attributo diventa una costante e deve sempre essere scritto in maiuscolo.\par
b) Nella dichiarazione di un metodo, il metodo, in caso di ereditariet\'e0, non pu\'f2 essere sovrascritto.\par
c) Nella dichiarazone di una classe, la classe non pu\'f2 essere ereditata.\par
\par
19) Operatore static\par
a) Nella dichiarazione di un attributo, in questo caso viene creata una sola ricorrenza di quell'attributo per tutti gli oggetti.\par
b) Nella dichiarazione di un metodo, il metodo pu\'f2 essere esguito senza istanziare un oggetto, ma usando come prefisso il nome della\par
classe a cui appartiene:\par
ad esempio:\par
int a;\par
String strA="10";\par
a=Integer.parseInt(strA);\par
\par
20) Model\par
Si definisce Model una classe che nasce per permettere la memorizzazione dei dati di un'enti\'e0. Di solito \'e8 l'immagine del record di una\par
tabella se facciamo riferimento al Modello relazionale, altrimenti \'e8 un oggetto di un modello ORM.\par
Quando si crea un Model bisogna rispettare le regole seguenti:\par
1) Tutti gli attributi devono essere privati;\par
2) Bisogna implementare un setter ed un getter per ogni attributo;\par
3) Bisogna fare l'override di toString, equals e hashCode;\par
4) Bisogna creare un costruttore di default;\par
5) Bisogna creare il costruttore parametrizzato;\par
6) Bisogna implementare l'interfaccia serializable.\par
\par
21) Pattern MVC\par
a) Model\par
La relazione che esiste tra la classe e gli oggetti corrispondenti \'e8 di 1 a molti;\par
b) Controller \par
La relazione che esiste tra la classe e gli oggetti corrispondenti \'e8 di 1 a 1;\par
c) View\par
Intesa come Gui(Swing,Pagine HTML,Mobile XML), Model<-->View di tipo scheda, che servono per l'inserimento, la modifica ed il dettaglio,\par
ma di solito esiste sempre un View associata ad un Model ti tipo elenco.\par
d) Servizio, si definisce servizio un controller con pi\'f9 metodi (tipo crud), che viene usato da un altro controller.\par
\par
upcasting serve per dichiarare un tipo specifico con un tipo generico una classe padre\par
il downcasting uso un oggetto generico con un oggetto specifico\par
\par
\par
Upcasting\par
Dipendente d= new Manager();\par
Dipendente\par
Manager\par
con il filtro se io capisco che li dovr\'f2 usare un oggetto di tipo manager forzer\'f2 la dichiarazione specificando la classe che mi serve.\par
Downcasting\par
(Manager)d.setArea\par
\par
passaggio per valori e riferimento;\par
passaggio per valori\par
passiamo per argomento un tipo primitivo\par
si passa la copia della variabile origiinale\par
\par
l'unico vera modifica che pu\'f2 ritornare dal metodo \'e8 un return.\par
ritornando un valore numerico si sovrascrive la variabile originale.\par
\par
nel passaggio per riferimento \par
parliamo passaggi del riferimento per oggetti\par
punta direttamente all'indirizzo di riferimento dell'oggetto. \par
se modifichi il punto dell'area con setter o getter, quell'oggetto viene modificato permanentemente\par
\par
nei linguaggi sono 3 le identit\'e0 \par
attributi, metodi e classi\par
\par
se i vettori sono unit\'e0 di memoria statiche \par
\par
una struttura dati \'e8 dinamica se pu\'f2 contenere al momento tutti i valori che distribuiscono \par
si pu\'f2 variare sia la dimensione che il contenuto\par
nuovo acronimo CRUD\par
Create=inserimento del dato\par
Read= lettura del dato / interrogazione del database\par
Update=aggiornamento del dato\par
Delete=cancellazione del dato\par
operazioni per la manipolazione dell'archivio\par
\par
Le liste non sono classi\par
interfaccia \'e8 comodo come promemoria\par
ICRUD\par
dove vengono riportati i metodi astratti \par
vengono riportati i metodi in crud cos\'ec da non dimenticare \par
\par
una classe pu\'f2 implementare pi\'f9 interfacce\par
riporta un metodo specifico\par
mi permette di utilizzare pi\'f9 genitori \par
avr\'f2 allineamenti dai metodi;\par
\par
interfaccia List.\par
permette di inserire secondo un determinato \par
l'ultimo che \'e8 stato inserito rimane l'ultimo della lista, e ci consente duplicati, quindi posso accettare due omonimi \par
se voglio usare un interfaccia senza duplicati \'e8 l'interfaccia set, decide l'ordinamento casuale, potremmo immaginare il set come un ordinamento matematico, ti sovrascrive cos\'ec i doppioni e li elimina\par
list invece seguendo l'ordine  di inserimento.  fai proprio una lista di cosa stai inserendo.\par
Queue = coda, il primo ad entrare \'e8 ilprimo che esce, subito sotto c'\'e8 deque, che sta per pila, ovvero l'ultimo ad entrare \'e8 il primo ad uscire\par
il queue fa aggiungere in coda il deque fa aggiungere in testa\par
LinkedList puoi aggiungere sia in testa che in coda e ha gli stessi metodi da ArrayList visto che attinge anche dall'interfaccia LIst\par
\par
set viene implementata su HashSet, quando \'e8 nato hashset non c'era ancora linkedhashset\par
con linkedhashset, che continua ad eliminarti i doppioni, ma rispetta l'ordine di inserimento \par
\par
length \'e8 un attributo per i vettori\par
il size \'e8 un metodo per le list\par
\par
consiglio : ripetere a mente mentre passeggi\par
\par
Pattern MVC\par
Modello architetturale\par
Model, View, Controller\par
Model=Classi sensibili addetta all' archiviazione 3)\par
View=interfaccia grafica (Solo qui ci saranno  i System.out e i System.in) 2)\par
Controller=Classi che hanno implementato logica esecuzione 1)\par
\par
Pagina web form con tante informazioni da inserire come nome cognome mail e bottone invia\par
\par
luca \par
metodo maschera inserimento \par
Persona p =new Persona()\par
p.setNome().input.nextLine();\par
\par
elenchiamo le tre fasi\par
primo step creo un oggetto vuoto di tipo Persona\par
un oggetto \'e8 un contenitore\par
che vado a riempire in una maschera\par
riempiamo con l'arraylist\par
un controller andiamo creare un oggetto di tipo view\par
voglio mettere una classe voglio rappresentare come model ma in realt\'e0 non \'e8 model\par
Classe Crud\par
ICRUD inserimento cancella\par
\par
durante l'esecuzione runtime togli i metodi \par
la stack memory \par
\par
\par
Ripasso Generale Linguaggio ad Oggetti \par
\par
il comando \par
\'e8 il metodo per istanziare l'oggetto.\par
il costruttore \'e8 quel metodo che serve ad inizializzare l'oggetto.\par
istanzia lui l'oggetto, autowired lui gli passa il riferimento. Quindi non  \par
Dipendenza Injection \par
Invertion on control \par
\par
il public assegnato ad ogni elemento viene visibile ai metodi delle altri classi, se \'e8 private non \'e8 visibile\par
per protected e default, nel caso non ereditiamo \par
\par
downcasting \par
\par
\par
1) Che cos'\'e8 una classe\par
Tipo di oggetto/Disegno di un oggetto\par
\par
2) Che cosa c'\'e8 in una classe\par
public class MiaCalsse\{\par
Attributi (Variabili d'istanza)\par
Metodi\par
Costruttori\par
\}\par
\par
3) Che cos'\'e8 un oggettto\par
Istanza di una classe\par
MiaClasse miaClasse=new MiaClasse();\par
\par
MiaClasse=Classe\par
miaClasse=Nome oggetto (riferimento oggetto)\par
new=Comando che crea l'oggettto\par
MiaClasse()=Costruttore.\par
\par
Esempio d'uso di un costruttore:\par
public class MiaClasse\{\par
Persona p=new Persona(); //Non \'e8 proprio corretta\par
Persona p;\par
...\par
public MiaClasse()\{\par
this.p=new Persona();\par
\}\par
\}\par
\par
4) Come si riconosce un costruttore\par
1) Stesso nome della classe\par
2) Nella dichiarazione del metodo non \'e8 indicato il tipo restituito\par
\par
5) A cosa serve un costruttore\par
I costruttori servono per inizializzare l'oggetto che si sta creando\par
\par
6) Quali sono i Paradigma ad Oggetti di programmazione\par
1) Incapsulamento\par
2) Ereditariet\'e0\par
3) Polimorfismo\par
\par
7) Quali sono i Paradigma ad Oggetti archetetturali\par
1) Coesione //Tutte le parti di una classe devono riflettere il dominio del problema\par
2) Disaccoppiamneto  //Non esiste perch\'e9 ogni volta che eseguite un new in un metodo accoppiate i due oggeti tra loro\par
\par
8) Che cos'\'e8 Incapsulamento\par
E' la proprit\'e0 del linguaggi ad Oggetti di nascondere gli elementi di una classe attraverso l'uso dei modificatori di accesso\par
\par
Quali sono i modificatori di accesso in Java (I modificatori di accesso si possono applicare solo agli attributi)\par
1)public\par
2)private\par
3)protect\par
4)default. La parola chiave default non esiste, se non si indica nessun modificatore allora vale default. Ex. int a;\par
\par
Quando descrivete i modificatori di accesso ricordate che la visibilit\'e0 pu\'f2 essere regolata nei seguenti casi:\par
1) Istanza (new)\par
2) Ereditariet\'e0 (extends)\par
3) Le classi possono essere nello stesso package oppure in package diversi\par
\par
9) Che cos'\'e8 l'Ereditariet\'e0\par
E' una tecnica di riuso del codice. La classe ereditata si chiama padre, quella che erdita si chiama figlia. La parola chiave per ereditare e extends.\par
In Java l'ereditariet\'e0 \'e8 singola, si pu\'f2 ereditare una sola classe per volta.\par
La classe figlia \'e8 detta anche classe specializzata.\par
\par
--> Spiegare la tecnica di gestione del costruttore parametrizzato (super()).\par
\par
10) Che cos'\'e8 il polimorfismo\par
1) Polimorfismo dei metodi: Overload/Override\par
2) Polimorfismo degli oggetti: Polimorfismo per Eredit\'e0 e per Interfaccia\par
\par
11) Che cos'\'e8 l'Overload\par
L'Overload \'e8 la propriet\'e0 dei linguaggio ad oggetti che ti permette in inserire nella stessa classe metodi con lo stesso nome ma firma diversa:\par
public Colora\{\par
   public void colora(int colore)\{\par
   ...\par
   \}\par
\par
   public void colora(String colore)\{\par
   ...\par
   \}\par
\par
   public void colora(int r,int g, int b)\{\par
   ...\par
   \}\par
\}\par
\par
12) Che cos'\'e8 la firma:\par
nome del metodo + tipi di argomenti, ad esempio:\par
1)  public void colora(int colore) la firma \'e8 colora int\par
2)  public void colora(String colore) la firma \'e8 colora String\par
3)  public void colora(int r,int g, int b) la firma \'e8 colora int int int\par
\par
13) Che cos'\'e8 l'Override\par
L'Override si applica solo nel caso dell'Ereditariet\'e0, serve a cambiare il comportmanto di un metodo ereditato, sovrascrivendolo.\par
I metodi ereditati e sovrascritti hanno all'inizio l'annotazione @Override\par
\par
14) Che cos'\'e8 il Polimorfismo degli oggetti per ereditariet\'e0\par
public class Persona extends Object\{\par
...\par
\}\par
\par
public class Dipendente extends Persona \{\par
...\par
\}\par
\par
public stampa(Persona p)\{   \par
...\par
\}\par
\par
Persona p=new Persona();\par
Dipendente d=new Dipendete();\par
stampa(p);\par
stampa(d); //Down-Casting     (Argomento)Persona p=d (Valore di tipo Dipendente)\par
\par
Up-Casting\par
if(p instanceof Dipendete)\{\par
Dipendente d=(Dipendente)p;\par
\}\par
\par
15) Che cos'\'e8 il Polimorfismo degli oggetti per interfaccia\par
\par
public class ArrayList implements List\{\par
...\par
\}\par
\par
public class LinkedList implements List\{\par
...\par
\}\par
\par
public stampa(List l)\{   \par
...\par
\}\par
\par
ArrayList al=new ArrayList();\par
LinkedList ll=new LInkedList();\par
\par
stampa(al);\par
stampa(ll);\par
\par
Thread \par
multi tasking tanti programmi che sono in esecuzione in contemporanea\par
\par
Multithreading Siamo in un unico programma e all'interno possiamo gestire pi\'f9 processi in parallelo. Se il Multithreading lo faccio con 2 thread questi sono due flussi sequenziali individuali \par
\par
per fare un piccolo programmino che lavora nel progetto vero e proprio, ogni classe contiene un metodo run\par
\par
Thread sono oggetti  java il cui flusso sequenziale lo troviamo scritto in un metodo run, ogni thread  viene attivato dal metodo start\par
il thread \'e8 un programmino in un programma, ha una sua personale stack memory \par
al  massimo ogni  thread aspetta l'ordine della sua pila stack, e di fatto ha una  sua pila stack, un thread se ne frega dell'altro thread perch\'e8 ha la sua pila stack, non curanti l'uno dell'altro,\par
\par
il metodo run() viene invocato da un metodo start()\par
start()->run un metodo start\par
\par
\par
\par
\b\par
\par
}
 