{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1040{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.18362}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang16 Processo di creazione di un Database con il Framework in Spring\par
1. Innanzitutto ho creato il Progetto tramite start.spring.io un sito web dove ho potuto creare un progetto Spring personalizzato, da cui potevo inserire tutte le Dependencies(Archivi di dipendenza che servono al progetto  per compilare, testare, costruire e/o eseguire ) necessarie al funzionamento del mio progetto. \par
2. Ho importato il progetto creato come tipo di file .war in Eclipse, successivamente sul progetto nella sezione "Maven" ho fatto l'update del progetto, cos\'ec da scaricarmi tutte le dependencies memorizzate nel mio file pom.xml, che verranno scaricate e caricate dalla Repository locale \par
\par
3. il progetto importato porta con se gi\'e0 un package (che sar\'e0 allocato nel percorso src/main/java ) con due classi all'interno,  una chiamata come il nome del progetto, e l'altra come ServletInitializer, nella prima, ci sar\'e0 solo un unico metodo, ovvero il metodo statico main, che servir\'e0 per l'esecuzione dell'applicativo, e all'interno verr\'e0 chiamato un metodo statico di nome run():  contenuto nella classe SpringApplication dove passer\'e0 per argomento la classe stessa e l'array di Stringhe per far partire le inizializzazioni su console di spring.\par
L'altra classe ServletInitializer estender\'e0 la classe SpringBootServletInitializer dove richiamer\'e0 dalla super classe il metodo statico sources che conterr\'e0 per argomento la classe con il nome del progetto, cos\'ec da avviare il framework Spring\par
\par
4.Come prima cosa inizier\'f2 a creare i package rispettando i percorsi principali del progetto. per quello importato sar\'e0 per esempio src/main/java/com/example, creando,  i package controller(dove conterr\'e0 le classi controller, che serviranno per la parte logica dell'applicativo), interfaces(dove conterr\'e0 l'interfaccia con i metodi astratti della Crud), model(dove ci saranno tutte le classi che saranno il corrispettivo delle tabelle nel mio database),repository(qui saranno contenute tutte le interfacce che estenderanno l'interfaccia generic JpaRepository )e infine nel package/service/impl inserir\'f2 la classe che implementer\'e0 l'interfaccia crud service che implementer\'e0 tutti i metodi dell'interfaccia che andr\'f2 a popolare.\par
\par
5. la prima cosa che sono andato a fare, sono le classi model, contenute nel package model, ho creato per prima cosa la classe Utenti e l'ho strutturata cos\'ec: \par
prima della dichiarazione della classe ho inserito due annotation, a monte @Entity specificando che la classe in questione \'e8 un'entit\'e0 mappata su una tabella del database\par
subito sotto ho inserito @Table(name="utenti") dove con l'annotation @Table andr\'f2 a definire il nome della tabella (che per convenzione, la tabella di solito viene chiamata al plurale, la classe al singolare).\par
all'interno della classe andr\'f2 a definire per prima il campo id tramite due annotations e la dichiarazione di una variabile; \par
la prima \'e8 @Id dove contrassegno il campo come una chiave primaria\par
e il secondo \'e8  @GeneratedValue viene utilizzata per specificare come generare la chiave primaria , io settandola con la costante AUTO richiamata dalla classe GenerationType e consente di scegliere a Spring la strategia di generazione; alla fine ho dichiarato l'attributo con visibilit\'e0 private(ricordando che le classi model sono classi sensibili, quindi per un fattore di sicurezza devono essere private) di tipo integer, creando setter e getter;\par
successivamente ho dichiarato le colonne con l'annotation @Column che mi consente di specificare i campi che avr\'e0 la mia tabella,  dichiarando naturalmente sempre gli attributi questa volta di tipo String, nome e cognome.\par
dopo di questo vad a fare tre dichiarazioni di chiave esterna che mi serviranno per collegare le altre tre tabelle create, per prima dichiaro per collegare la tabella account una annotation @OneToOne che relaziona la tabella account con una relazione uno ad uno, quindi un utente avr\'e0 un solo account , e definisco il campo sia con la costante EAGER richiamando la classe FetchType (EAGER  indica che l\rquote oggetto di campo/relazione sar\'e0 caricato al momento della creazione dell\rquote oggetto che lo contiene),solo per l'idaccount ho utilizzato CascadeType.ALL dove indicher\'f2 che la persistenza propagher\'e0 a cascata tutte le operazioni.\par
subito dopo dichiaro l'annotation @joinColumn per definire la chiave esterna inserendo il nome dell'id della chiave esterna, definendo che la chiave non dovr\'e0 essere null. E infine dichiaro un oggetto di tipo Account per gestire la correlazione con l'altra classe\par
stessa cosa dichiarer\'f2 per l'id_ruolo ma lo gestisco con una relazione ManyToOne che definisce che un utente pu\'f2 avere solo un ruolo, ma dall'altra parte nella classe Ruolo avr\'e0 una relazione OneToMany dove dico che un ruolo pu\'f2 essere assegnato a pi\'f9 utenti\par
dichiaro un oggetto di tipo Ruolo  per gestirmi il singolo oggetto, ed una lista di tipo Ruolo nella classe ruolo, per gestirmi la lista completa dei ruoli per la OneToMany\par
per ultimo far\'f2 una correlazione con l'annotation ManyToMany con la classe Progetto dove praticamente sto dicendo che la relazione tra Progetto e Utente \'e8 molti a molti, in questi casi devo creare una tabella normalizzata dove conterr\'e0 solo le chiavi esterne delle due tabelle. \par
dichiaro sempre la costante EAGER e subito sotto dichiaro l'annotation @joinTable, dove inserir\'f2 il nome della tabella, e gestir\'f2 con joincolumn e inversejoincolumn le due chiavi esterne chiamandole e rispettando la stessa cosa nella classe progetto.\par
creeo in entrambi le classi due liste, una di tipo Progetto in Utente ed un'altra di tipo Utente in Progetto.\par
nella classe Account , Ruolo, e Progetto far\'f2 la stessa cosa, solo che in account e ruolo per gestire il collegamento creo un oggetto di tipo utente e richiamo la annotation OneToOne, in pi\'f9 alle solite dichiarazioni inserir\'f2 il mappedby dove vado a definire l'oggetto di tipo account dichiarato nella classe Utente al momento della creazione della chiave esterna. \par
6. dopo la creazione delle model sono andato a creare la mia prima crud ovvero la insert per il ruolo , per prima cosa nel package repository ho creato la mia prima interfaccia chiamata IRepoUtente siccome \'e8 una generic passer\'f2 due valori , l'oggetto che in questo caso \'e8 il Ruolo, e l'id in questo caso con la classe Wrapper Integer, all'interno dell'interfaccia richiamer\'f2 il metodo findById (associato alla ricerca dell'id del  ruolo ) e come argomento passer\'f2 una variabile di tipo integer per ricercare tramite id, stessa cosa far\'f2 creando sia IrepoAccount che IRepoUtente e IRepoProgetto.\par
All'interno del package Interfaces creo una interfaccia chiamata IService e creo la prima crud chiamata void insertRuolo(Ruolo r) , void in questo caso perch\'e8 non mi deve tornare nulla dato che \'e8 un inserimento e passo come parametro un oggetto di tipo Ruolo e passarlo come riferimento fino al controller, nella classe serviceimpl, implemento il metodo creato nella IService per fare un Override, e all'interno passarci l'oggetto di tipo IRepoRuolo (che ho creato con l'annotation @Autowired che inietta l'oggetto iniettandolo nella classe senza che debba essere istanziato,) e richiamo il metodo save con argomento l'oggetto ruolo  per salvarlo.\par
in questo caso ora creo il file jsp dove inserir\'f2 una tag form che porta alla servlet dichiarandola tramite action dove inserir\'f2 il percorso della servlet e dichiarer\'f2 il metodo come post. all'interno inserir\'f2 il tag input per inserire il ruolo e un button di tipo submit\ul\par
\ulnone inizio a creare il mio primo controller come classe Inserimento.java e dichiaro due annotations  prima della dichiarazione della classe. La prima sar\'e0 @Controller dove definisco la classe come controller e quindi come classe che gestisce gli algoritmi logici, subito dopo la @RequestMapping dove definir\'f2 il percorso iniziale di questa classe controller. All'interno della classe richiamo con l'Autowired annotation la classe Iservice \par
e creo il mio primo inserimento del  ruolo in questo caso, e prima della dichiarazione del metodo faccio una @RequestMapping con il valore del percorso di questo metodo in questo caso lo chiamo insertRuolo e come metodo richiamo la costant Post dalla classe RequestMethod per dichiarare che  il metodo sta facendo un inserimento. Subito dopo dichiaro un metodo che mi fa tornare una stringa (la stringa sar\'f2 il nome della jsp di arrivo) per argomento dichiaro tramite annotation di @RequestParam( annotation che serve per definire un parametro che passer\'f2 tramite name sulle tag html) lo string ruolo \par
Istanzio l'oggetto di tipo Ruolo con il costruttore, richiamo tramite l'oggetto il metodo setRuolo e ci passo come argomento il parametro che ho dichiarato con il request param, per legarlo dal front end al back end \par
subito dopo inserisco metodo di inserimento della classe che implementa le service richiamandolo dall'oggetto iniettato e passandoci l'oggetto di tipo Ruolo istanziato\par
per return inserisco una pagina che mi mander\'e0 ad una pagina jsp chiamata success\par
\par
7.prima di avviare il tutto e dopo aver creato le classi per le tabelle vado sulle properties ed inserisco il nome del mio database sul percorso mySql, e poi creo sul php il mio database usando il comando sql create database provaspring da l\'ec non toccher\'f2 pi\'f9 il database perch\'e8 tutto quanto sar\'e0 inserito direttamente dal mio progetto spring, avvio intanto il mio progetto per creare tutte le mie tabelle e relazioni sul database, tramite l'avvio della mia prima jsp inserimentoruolo.jsp all'avvio del run di eclipse il mio database viene generato tramite l'applicativo, tutti i progressi vengono visualizzati sulla mia console,  e inizio inserendo intanto i miei primi due ruoli, ovvero Admin e Guess, dopo aver creato l'inserimento, procedo allo stesso modo con l'inserimento dell'account e utente, i passaggi fino alla serviceimplement saranno gli stesso, ma in questo caso salver\'f2 un oggetto di tipo Utente, nel controller setter\'f2 tutti i campi di utente account e ruolo istanziando gli oggetti relativi \par
ma l'oggetto di ripo ruolo lo associer\'f2 alla service del metodo che  ho creato far\'e0 ritorner\'e0 una lista di ruoli presa dal metodo inserito in IRepoRuolo findByRuolo(String ruolo), cos\'ec da inserire il ruolo tramite una select nella pagina della jsp di inserimento dell'utente \par
al metodo contenuto nella classe utente ovvero setRuolo ci associer\'f2 l'oggetto di tipo Ruolo cos\'ec da impostare l'oggetto e settarlo in back end associandolo al suo id\par
ora richiamo il metodo setAccount dalla classe Utente che passo per argomento l'oggetto di tipo Account cos\'ec da far passare prima e settare i campi in account e poi passo l'argomento setUtente nella classe Account come argomento passo l'oggetto Utente cos\'ec da memorizzare i campi di utente, in questo caso non devo chiamare il ruolo perch\'e8 mi porto appresso il setRuolo in utente che ho precedentemnte settato, e infine richiamo il metodo insertUtente(u).\par
insertProgetto() funziona simile al ruolo ma inserir\'f2 un nome di un progetto ed una descrizione, \par
nella jsp con la form di inserimento utente, non cambia quasi nulla con il ruolo, ma inserir\'f2 per la select di ruolo una jQuery che mi ritorna la lista dei ruoli all'interno di una tag foreach cos\'ec da iterare tutti i ruoli nella lista senza inserire un option per ogni ruolo.\par
8.successivamente per le maschere ho creato in back end nella IService dei metodi che ritornano delle liste di tipo diverso come utente per esempio. \par
Nel controller passeremo per argomento del metodo un oggetto di tipo ModelMap (utilizzata per passare valori per il rendering di una vista ) e nel mapping definiamo questa volta un get nel RequestMethod, perch\'e8 vogliamo prendere questa volta i dati dal database \par
nel metodo dichiaro una List di tipo Utente associata alla service che mi fa tornare la lista di utenti,  poi la passo nel metodo richiamato con l'oggetto ModelMap  e lo associo ad una stringa che dichiarer\'f2 nella jsp con una dichiarazione in JQuery. nella jsp  creo  una  tabella, e passo con la tag for each  l'items listaUtenti dando un valore per associarlo e richiamare nella tabella tutti i campi da visualizzare nella tabella in jQuery richiamando i get dei campi delle classi model.\par
9.l'inserimento di una persona in un progetto funziona passando in un metodo nella classe inserimento  due id uno per utente ed uno per progetto \par
nel metodo invece associo i due metodi contenuti nella service precedenmenti creati che cercano utenti e progetto ci passo i due id creati nell'argomento del metodo che cercano nella tabella tramite campo id ,  ai due oggetti di tipo Utente e Progetto.\par
poi con il metodo getUtenti che mi ritorna una lista di utenti ci associo il metodo add che aggiunge l'oggetto di tipo utente( nota: stamper\'e0 se viene richiamato l'oggetto il metodo toString dalla classe Object )\par
infine richiamo il metodo insertProgetto(p) (lo stesso dell'inserimento del progetto, dato che vogliamo aggiungere l'utente nel progetto, ricordando che in Progetto abbiamo la lista Utenti)\par
\par
\par
 \par
\par
}
 